# -*- coding: utf-8 -*-
"""expneural.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SLwjhWt3hi7AYmVuG1LDtW6CPjHNGQQY
"""

import numpy as np

def get_context_list(qubit_list):
    context_group1 = []
    qubit = qubit_list[0]
    for i in range(qubit+1):
        new_d = np.array([i,qubit-i])
        context_group1.append(new_d)
    context_group1 = np.array(context_group1)

    context_group2 = []
    qubit = qubit_list[1]
    for i in range(qubit+1):
        new_d = np.array([i,qubit-i])
        context_group2.append(new_d)
    context_group2 = np.array(context_group2)

    context_group3 = []
    qubit = qubit_list[2]
    for i in range(qubit+1):
        for j in range(qubit+1-i):
            new_d = np.array([i,j,qubit-i-j])
            context_group3.append(new_d)
    context_group3 = np.array(context_group3)

    context_group4 = []
    qubit = qubit_list[3]
    for i in range(qubit+1):
        for j in range(qubit+1-i):
            new_d = np.array([i,j,qubit-i-j])
            context_group4.append(new_d)
    context_group4 = np.array(context_group4)

    X_n = []
    X_n.append(context_group1)
    X_n.append(context_group2)
    X_n.append(context_group3)
    X_n.append(context_group4)
    return X_n

qubit_list = [8,10,8,9]
# qubit_list = [9,11,17,18]
X_n = get_context_list(qubit_list)

print(X_n)

def get_reward_1(X_n):
    A = 4000
    reward = []

    # 繁忙时期 qubit较少 a>b>c>d

    # route a, 1 hop, 2 edges
    # 单跳单qubit单次纠缠成功率
    pe_a_1 = 1.5e-4
    pe_a_2 = 1.5e-4
    # 单跳单qubit单slot(A次)纠缠成功率
    p_a_1 = 1 - (1 - pe_a_1)**A
    p_a_2 = 1 - (1 - pe_a_2)**A
#     # 单跳qubit数量
#     n_a_1 = 4
#     n_a_2 = 4
    # 单跳成功率
    for j in range(len(X_n[0])):
#         P_a_1 = 1 - (1 - p_a_1)**n_a_1
#         P_a_2 = 1 - (1 - p_a_2)**n_a_2
        P_a_1 = 1 - (1 - p_a_1)**X_n[0][j][0]
        P_a_2 = 1 - (1 - p_a_2)**X_n[0][j][1]
        # route a 成功率
        P_a = P_a_1 * P_a_2
        reward.append(P_a)
    return reward

def get_reward_2(X_n):
    A = 4000
    reward = []

    # 繁忙时期 qubit较少 a>b>c>d

    # route a, 1 hop, 2 edges
    # 单跳单qubit单次纠缠成功率
    pe_b_1 = 1e-4
    pe_b_2 = 1e-4
    # 单跳单qubit单slot(A次)纠缠成功率
    p_b_1 = 1 - (1 - pe_b_1)**A
    p_b_2 = 1 - (1 - pe_b_2)**A
#     # 单跳qubit数量
#     n_a_1 = 4
#     n_a_2 = 4
    # 单跳成功率
    for j in range(len(X_n[1])):
#         P_a_1 = 1 - (1 - p_a_1)**n_a_1
#         P_a_2 = 1 - (1 - p_a_2)**n_a_2
        P_b_1 = 1 - (1 - p_b_1)**X_n[1][j][0]
        P_b_2 = 1 - (1 - p_b_2)**X_n[1][j][1]
        # route a 成功率
        P_b = P_b_1 * P_b_2
        reward.append(P_b)
    return reward

def get_reward_3(X_n):
    A = 4000
    reward = []

    # 繁忙时期 qubit较少 a>b>c>d

    # route a, 1 hop, 2 edges
    # 单跳单qubit单次纠缠成功率
    pe_c_1 = 2e-4
    pe_c_2 = 2e-4
    pe_c_3 = 2e-4
    # 单跳单qubit单slot(A次)纠缠成功率
    p_c_1 = 1 - (1 - pe_c_1)**A
    p_c_2 = 1 - (1 - pe_c_2)**A
    p_c_3 = 1 - (1 - pe_c_3)**A
#     # 单跳qubit数量
#     n_a_1 = 4
#     n_a_2 = 4
    # 单跳成功率
    for j in range(len(X_n[2])):
#         P_a_1 = 1 - (1 - p_a_1)**n_a_1
#         P_a_2 = 1 - (1 - p_a_2)**n_a_2
        P_c_1 = 1 - (1 - p_c_1)**X_n[2][j][0]
        P_c_2 = 1 - (1 - p_c_2)**X_n[2][j][1]
        P_c_3 = 1 - (1 - p_c_3)**X_n[2][j][2]
        # route a 成功率
        P_c = P_c_1 * P_c_2 * P_c_3
        reward.append(P_c)
    return reward

def get_reward_4(X_n):
    A = 4000
    reward = []

    # 繁忙时期 qubit较少 a>b>c>d

    # route a, 1 hop, 2 edges
    # 单跳单qubit单次纠缠成功率
    pe_d_1 = 1.5e-4
    pe_d_2 = 1.5e-4
    pe_d_3 = 1.5e-4
    # 单跳单qubit单slot(A次)纠缠成功率
    p_d_1 = 1 - (1 - pe_d_1)**A
    p_d_2 = 1 - (1 - pe_d_2)**A
    p_d_3 = 1 - (1 - pe_d_3)**A
#     # 单跳qubit数量
#     n_a_1 = 4
#     n_a_2 = 4
    # 单跳成功率
    for j in range(len(X_n[3])):
#         P_a_1 = 1 - (1 - p_a_1)**n_a_1
#         P_a_2 = 1 - (1 - p_a_2)**n_a_2
        P_d_1 = 1 - (1 - p_d_1)**X_n[3][j][0]
        P_d_2 = 1 - (1 - p_d_2)**X_n[3][j][1]
        P_d_3 = 1 - (1 - p_d_3)**X_n[3][j][2]
        # route a 成功率
        P_d = P_d_1 * P_d_2 * P_d_3
        reward.append(P_d)
    return reward

reward_list = []
reward_list.append(get_reward_1(X_n))
reward_list.append(get_reward_2(X_n))
reward_list.append(get_reward_3(X_n))
reward_list.append(get_reward_4(X_n))

for i in range(len(reward_list)):
    print(max(reward_list[i]))

import random
from random import choice
filename1 = 'dataset/markov_attack_list_0713_2022_1.txt'
attack_list =  np.loadtxt(filename1)
frame_number = len(attack_list)
oracle_path_action_list = []

for graph_index in range(len(reward_list)):
    oracle_graph_list = []
    for partition_point in range(len(reward_list[graph_index])):
        oracle_frame_list = []
        for frame in range(frame_number):
            dt = reward_list[graph_index][partition_point]*attack_list[frame][graph_index]
            oracle_frame_list.append(dt)
        oracle_graph_list.append(oracle_frame_list)
    oracle_path_action_list.append(oracle_graph_list)

# print(dt_list[405:410])
# print(oracle_path_action_list)

print(attack_list[0])

a0 = 0
a1 = 0
a2 = 0
a3 = 0
# attack_list[:,0].count(0)
for i in range(len(attack_list)):
    if attack_list[i][0] == 0:
        a0 = a0 + 1
    if attack_list[i][1] == 0:
        a1 = a1 +1
    if attack_list[i][2] == 0:
        a2 = a2 +1
    if attack_list[i][3] == 0:
        a3 = a3 +1
print(a0,a1,a2,a3)

max_graph_action = []
oracle_graph_list = []
for graph_index in range(len(reward_list)):
    x_list = []
    x_index_list =[]
    for partition_point in range(len(reward_list[graph_index])):
        x = sum(oracle_path_action_list[graph_index][partition_point])
        x_list.append(x)
    oracle_graph_list.append(max(x_list))
    print(oracle_graph_list)
    max_graph_action.append(x_list.index(max(x_list)))
print(oracle_graph_list)
oracle_path = oracle_graph_list.index(max(oracle_graph_list))
oracle_action = max_graph_action[oracle_graph_list.index(max(oracle_graph_list))]
print('oracle path = ',oracle_graph_list.index(max(oracle_graph_list)),'oracle action = ',max_graph_action[oracle_graph_list.index(max(oracle_graph_list))])

"""# EXP_NEURAL"""

import random
from random import choice
from env import *
from neuralucb import *
import matplotlib.pyplot as plt
import torch
from tqdm import trange
import random
import math
import time
import psutil
import os

# filename1 = 'dataset/markov_attack_list_0626_6.txt'
attack_list =  np.loadtxt(filename1)
regret_list_neuralucbexp = []
regret = 0
r_list_neuralucbexp = []
r_total = 0
prob_list = []

estimate_group_reward =[]
estimate_path_action_list = []
allocation_array = []
gamma = 1*math.pow(frame_number,-1/4)*math.sqrt(math.log(frame_number))
eta = 1*math.sqrt(1/frame_number)
for i in range(len(reward_list)):
    estimate_group_reward.append([0])
    allocation_array.append(i)

neuralucb_list = []
beta = 0.2
neuralucb_list.append(NeuralUCB(2, len(X_n[0]), beta, lamb=1))
neuralucb_list.append(NeuralUCB(2, len(X_n[1]), beta, lamb=1))
neuralucb_list.append(NeuralUCB(3, len(X_n[2]), beta, lamb=1))
neuralucb_list.append(NeuralUCB(3, len(X_n[3]), beta, lamb=1))

# neuralucb_0 = NeuralUCB(2, len(X_n[0]), beta=1, lamb=1)
# neuralucb_1 = NeuralUCB(2, len(X_n[1]), beta=1, lamb=1)
# neuralucb_2 = NeuralUCB(3, len(X_n[2]), beta=1, lamb=1)
# neuralucb_3 = NeuralUCB(3, len(X_n[3]), beta=1, lamb=1)
start_time = time.time()
for frame in range(frame_number):
    estimate_path_action = []
    collect_path_action = []
    group_pro = []
    prob_array = []
    sum_group = 0
    for graph_index in range(len(reward_list)):
        arm = neuralucb_list[graph_index].take_action(X_n[graph_index])
#         while reward_list[graph_index][arm] == 0:
#             arm = arm-1
        collect_path_action.append([graph_index,arm]) #collect each group and its optimal actoin
    for group_index in range(len(estimate_group_reward)):
        sum_group = sum_group +math.exp(eta*sum(estimate_group_reward[group_index]))
    print(sum_group)
    for group_index in range(len(estimate_group_reward)):
        p =gamma/len(reward_list) + (1-gamma)*math.exp(eta*sum(estimate_group_reward[group_index]))/sum_group
        prob_array.append(p)
    print(frame)
    print(prob_array)
    prob_list.append(prob_array)
    estimate_path = np.random.choice(allocation_array,p=prob_array) #sample group based on prob array
    estimate_action = collect_path_action[estimate_path][1] #get optimal action of sampled group
    estimate_path_action.append(estimate_path)
    estimate_path_action.append(estimate_action)
    estimate_path_action_list.append(estimate_path_action)
    print('estimate_path:',estimate_path,'estimate_action:',estimate_action)

    X_t = reward_list[estimate_path][estimate_action]

    d_t = np.random.choice([0,1],p=[1-X_t, X_t])

    dt = d_t*attack_list[frame][estimate_path]
    Xt = X_t*attack_list[frame][estimate_path]


#     if dt> 0:
# #         dt = dt + index
#         dt = dt + random.uniform(mu, sigma)

    if attack_list[frame][estimate_path] > 0 :
#         print('d_t:',d_t)
#         neuralucb_list[estimate_path].update(X_n[estimate_path], estimate_action, d_t)
        neuralucb_list[estimate_path].update(X_n[estimate_path], estimate_action, X_t)

    r_total = r_total +Xt
    r_list_neuralucbexp.append(r_total)
    for group_index in range(len(reward_list)):
        if group_index == estimate_path:
#             estimate_group_reward[group_index].append(Xt/prob_array[estimate_path])
            estimate_group_reward[group_index].append(dt/prob_array[estimate_path])
        else :
            estimate_group_reward[group_index].append(0)# give a abnormal value if selected group is attack or unselected group
#     c_oracle = np.array(partitionInfo[action_oracle])
#     oracle_dt = np.matmul(true_graph_theta[path_oracle],c_oracle.T)*attack_list[frame][path_oracle]

#     if oracle_dt == 0:
#         oracle_dt = D
#     oracle_r = D - oracle_dt
# #     if dt == 0:
# #         dt = 1
    oracle_r = reward_list[oracle_path][oracle_action]*attack_list[frame][oracle_path] - Xt
    if oracle_r < 0:
        oracle_r = 0

    regret = regret + abs(oracle_r)
    regret_list_neuralucbexp.append(regret)
# print(estimate_path_action_list)
end_time = time.time()
elapsed_time = end_time - start_time
process = psutil.Process(os.getpid())
print(f"进程内存使用情况: {process.memory_info().rss / 1024 ** 2} MB")

# import matplotlib.pyplot as plt
import numpy as np
import matplotlib.pyplot as plt
t = np.arange(0,4000,1)
# plt.figure().set_size_inches(8,6)
plt.figure(figsize=(6,4))
# plt.figure()
# t = np.arange(0,3000,1)

# plt.title('Group Probability with attack(Mix Task,Same D=1.1)')
# plt.title('Group Probability with attack(Mix Task)')
# plt.title('Group Probability with attack(Mix Task,,Adaptive D)')
# plt.title('Group Probability with attack(YOLO,D=1.1,changing network)')
# plt.title('Group Probability with attack(Resnet,D=1.1,changing network)')
# plt.title('Group Probability with attack(Resnet,D=1.1,Attack reversion)')
plt.title('Group Probability with attack(much qubit)')
# plt.title('Group Probability with attack(less qubit)')

# prob_array = np.loadtxt("0715dataset/res_ucbexp_prob_list_d_11_4t.txt")  # (8000, 2)
# prob_array = np.loadtxt("0715dataset/res_ucbexp_prob_list_d_11n_1_cut13.txt")  # (8000, 2)
# prob_array = np.loadtxt("0715dataset/res_ucbexp_prob_list_d_11n_d1.txt")  # (8000, 2)
# prob_array = np.loadtxt("res_ucbexp_prob_list_d_11_4t.txt")  # (8000, 2)
# prob_array = np.loadtxt("y5r5_ucbexp_prob_list_d_11s_1.txt")  # (8000, 2)
# prob_array = np.loadtxt("0715dataset/y5r5_ucbexp_prob_list_d_11s_1.txt")  # (8000, 2)
# prob_array = np.loadtxt("0715dataset/y5r5_ucbexp_prob_list_d_11s_1 1.txt")  # (8000, 2)
# prob_array = np.loadtxt("0715dataset/y2r8_ucbexp_prob_list_d_11s_1.txt")  # (8000, 2)
# prob_array = np.loadtxt("0714dataset/yolo_ucbexp_prob_list_d_11_1_c.txt")  # (8000, 2)
# prob_array = np.loadtxt("0714dataset/resnet_ucbexp_prob_list_d_11_1_c.txt")  # (8000, 2)
# # prob_array = np.loadtxt("0715dataset/yolo_ucbexp_prob_list_d_11n_1_cut13.txt")  # (8000, 2)
# prob_array = np.loadtxt("0715dataset/yolo_ucbexp_prob_list_d_8n_1_cut13.txt")  # (8000, 2)
group1 = []
group2 = []
group3 = []
group4 = []
for i in range(len(prob_list)):
    group1.append(prob_list[i][0])
    group2.append(prob_list[i][1])
    group3.append(prob_list[i][2])
    group4.append(prob_list[i][3])

plt.plot(t, group1, color='green', label = 'Path 1',linestyle="--",linewidth=2)
plt.plot(t, group2, color='red', label = 'Path 2',linestyle="--",linewidth=2)
plt.plot(t, group3, color='blue', label = 'Path 3',linestyle="--",linewidth=2)
plt.plot(t, group4, color='purple', label = 'Path 4',linestyle="--",linewidth=2)
plt.legend(fontsize=18,loc = 'lower right')
# plt.legend(fontsize=18)
plt.tick_params(labelsize=19)
plt.grid()
plt.xlabel('Task Number',fontsize=20)
plt.ylabel('Sampling Distribution',fontsize=20)

# plt.annotate(text="Attack distribution change", xy=(2000, 0.4), xytext=(2200, 0.53),arrowprops={"arrowstyle":"->"},fontsize=16)

# plt.annotate(text="Task distribution change", xy=(2000, 0.4), xytext=(2100, 0.5),arrowprops={"arrowstyle":"->"},fontsize=18)
# plt.vlines(2000, 0, 0.8, colors = "c", linestyles = "dashed",linewidth=6)
plt.tight_layout()
# plt.savefig('Group Probability with attack(Mix Task,probability Reversion, D=1.1).png', format='png')
# plt.savefig('Group Probability with attack(YOLO,D=0.8).png', format='png')
# plt.savefig('Group Probability with attack(less qubit).png', format='png')
# plt.savefig('Group Probability with attack(Mix Task,Same probability 1).png')
# plt.savefig('Group Probability with attack(Adaptive attacker).png', format='png')
# plt.savefig('Group Probability with attack(ResNet,D=1.1,Attack reversion).png', format='png')
plt.show()

# filename = 'res_ucbexp_prob_list_d_11_3t.txt'
# filename = 'res_ucbexp_prob_list_d_11n_1_cut13.txt'
filename = 'few_ucbexp_prob_list.txt'
# filename = 'yolo_ucbexp_prob_list_d_11n_1_cut13.txt'
# filename = 'yolo_ucbexp_prob_list_d_8n_1_cut13.txt'
# np.savetxt(filename,prob_list)

import matplotlib.pyplot as plt
import numpy as np

# Data for plotting
t = np.arange(0,4000,1)
# t = np.arange(0,3000,1)

fig, ax = plt.subplots()
ax.plot(t, regret_list_neuralucbexp)

ax.set(xlabel='Frame Number', ylabel='Cumulative Regret',
       title='EXPNeuralUCB Cumulative Regret with Attack')
ax.grid()

# fig.savefig("test.png")
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Data for plotting
t = np.arange(0,4000,1)
# t = np.arange(0,3000,1)

fig, ax = plt.subplots()
ax.plot(t, r_list_neuralucbexp)

ax.set(xlabel='Frame Number', ylabel='Cumulative Reward',
       title='EXPNeuralUCB Cumulative Reward with Attack')
ax.grid()

# fig.savefig("test.png")
plt.show()

print(f"代码运行时间: {elapsed_time} 秒")